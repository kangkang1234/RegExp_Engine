## 功能

### 1. 普通字符
ascii表上从32号开始到126号的所有字符，即控制字符之外的所有字符
### 2. 元字符
. \w \s \d \b
### 3. 转义字符
\
### 4. 重复
\* 重复零次或者更多次
\+ 重复一次或者更多次
? 重复一次或者零次
{m,n} 重复m到n次
### 5. 字符类
eg:[aeiou]匹配任何一个元音字母
### 6. 分支条件
|

## 处理流程
正则表达式->预处理后缀表达式->nfa->dfa->最小化dfa

## 数据结构
##### 正则表达式：
`string`
##### 表达式优先级表
1代表当前字符优先级大于栈顶优先级，此时应进栈；0代表当前字符优先级小于栈顶优先级，此时应出栈
`priorityTable = *(new vector<vector<int>>`
`{ {0,0,0,0,0,0,1,0},{0,0,0,0,0,0,1,0},{0,0,0,0,0,0,1,0},{1,1,1,0,1,1,1,0},{0,0,0,0,0,0,1,0},{1,1,1,0,1,0,1,0},{1,1,1,1,1,1,1,0},{-1,-1,-1,-1,-1,-1,-1,-1} }`
横轴为当前字符 * + ? | rp · ( )
纵轴为栈顶字符 * + ? | rp · ( )
rp代表重复{m,n}操作
值得一提的是，这里将重复也作为一种操作符，rp操作会将按照正则语法对字符串进行重复，例如e{3,5}会被转化为eeee?e? 转为数字就是101 101 101 101 143 101 143
##### 预处理后缀表达式：
存放预处理之后的字符流，以int类型表示
`vector<int>infix`中缀表达式
`vector<int> prefix`后缀表达式
##### 字符类表：
0\~4存放元字符，之后存放自定义的字符类
`vector<vector<int>>chSet`
##### 数字字符对照：
0\~127对应ascii表上所有字符，128\~140对应元字符.\w\s\d\b[...]，141~148对应nfa构造符*+?|{n}·() 160表示nfa的空转移字符ε
##### nfa,dfa,最小化dfa:
利用邻接表的方式存储，顶点利用bool类型的final变量来标识是否为终结状态


## 算法
##### 中缀表达式转后缀表达式
初始输入的是字符串，要经过预处理将字符串转化为数字串，每个数字有不同的含义(参见数字字符对照)，值得一提的是在这个过程中需要添加nfa构造符 · 表示nfa的连接运算，之后利用表达式优先级表将中缀表达式转化为后缀表达式
##### nfa构造算法
参与nfa构造的运算符有* + ? | ·
###### nfa构造 *
![avatar](/nfa构造0.png)
###### nfa构造 +
![avatar](/nfa构造1.png)
###### nfa构造 ?
![avatar](/nfa构造2.png)
###### nfa构造 |
![avatar](/nfa构造3.png)
###### nfa构造 ·
![avatar](/nfa构造4.png)
##### nfa转dfa(子集构造法)
子集构造法的算法原理有非常多的资料阐述，但是值得一提的是我在编程过程遇到的两个问题：

Q1：求epsilon_closure的时机是在什么时候？<br/>A1：当且仅当每次状态转移结束的时候

Q2：在什么时候向状态集集合中添加新的状态集，即什么时候可以确定某个状态集合是新的状态集合
<br/>A2：应该遍历当前状态集合setA中的每个状态a，求出每个状态a通过当前字符可以转移的所有状态集集合setsB的并集setC，并考察setC是否为一个新集合，如果setC是新集合，则向状态集集合中添加setC，并创建一个dfa的新节点
##### 最小化dfa算法(hopcroft算法)
###### 基本思想
```
split(s)
    foreach(character c)
        if(c can split s)
            split s into T1, ..., Tk
hopcroft()
    split all nodes into N, A
    while(set is still changes)
        split(s)
```
基本思想比较容易理解，初始有两个集合，将所有终结状态合并为终结集合，所有非终结状态合并为非终结集合，然后调用hopcroft算法：如果某个字符可以划分某个集合，就进行该集合的划分，直到所有字符都无法划分任何集合（此时集合的数量就不会发生改变）

Q1：在什么情况下，集合是可以划分的？
<br/>A1：给定一个DFA M，如果从某个状态P开始，以字符串w作为输入，DFA M将结束于终态，而从另一状态Q开始，以字符串w作为输入，DFA M将结束于非终止状态，则称字符串w把状态P和状态Q区分开来

Q2：如何划分集合？
<br/>A2：我的实现是构造一个状态到集合转换表，数据结构是一个vector，键是可划分集合的所有状态，值是该状态通过当前符号ch能转移到的已知集合，而转移到相同集合的状态应该划分到一起

Q3：如果对于某个字符ch，状态P(所在集合A)可以转移到集合B,状态Q(所在集合A)不可以转移到任何集合，此时P和Q是否可划分？
<br/>A3：可划分，是否可划分的定义是：给定一个DFA M，如果从某个状态P开始，以字符串w作为输入，DFA M将结束于终态，而从另一状态Q开始，以字符串w作为输入，DFA M将结束于非终止状态，则称字符串w把状态P和状态Q区分开来，而上述例子中，假设B集合为终止状态集合，则ch可以将P转化为终止状态，而ch会将Q转化为非终结状态(不可达状态)，因此这两个状态是可划分的。这个问题的提出是因为在测试过程中，对某个dfa错误化简导致匹配错误，原因是我并未将不可达状态也看作非终结状态

## 接口
##### 创建正则表达式对象
`RegExp(string s)`
##### 匹配方法
`bool RegExp::RegExp_match(const string& s)`
## Todo List
##### 语法检查：
支持合法的正则语法，但缺少语法检查功能，如果输入不合法的正则表达式会导致未知异常。期望的解决方法是利用lex生成一个语法解析程序，并在语法检查阶段调用
##### 零宽断言，捕获，反向引用
以DFA为基础的正则引擎无法实现上述功能，需要使用NFA和DFA的混合引擎
##### 性能
DFA的生成所耗费的时间复杂度是指数级的，过长的正则表达式会导致性能爆炸，但是状态转换时间复杂度为常数级。NFA的生成时间复杂度是线性的，但是状态转换的时间复杂度为M的平方(M为表达式规模)
##### 测试
只是简单测试了基本语法，缺少详细的正确性测试和性能测试，为了方便测试，将NFA和DFA图进行可视化是很重要的，这个可以利用QT来实现

## 感谢
非常感谢在github上的一份[华南师范大学实验报告](https://github.com/sureyet/SCNU-CompilerLab2)，里面的代码对我很有启发，在此基础上我对代码进行重写并进行了功能扩展
大学的时候就很想做一个正则引擎，但是~~当初太懒~~没有完成，算是了了心愿

